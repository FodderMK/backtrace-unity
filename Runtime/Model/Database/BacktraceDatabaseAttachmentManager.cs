using Backtrace.Unity.Common;
using Backtrace.Unity.Types;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;

namespace Backtrace.Unity.Model.Database
{
    /// <summary>
    /// Backtrace Database attachment manager. Manage built-in BacktraceDatabase attachments
    /// </summary>
    internal class BacktraceDatabaseAttachmentManager
    {
        internal int ScreenshotMaxHeight { get; set; }
        internal int ScreenshotQuality { get; set; }

        private readonly BacktraceDatabaseSettings _settings;
        private float _lastScreenTime;
        private string _lastScreenPath;
        private List<string> _screens;
        private readonly object _lock = new object();
        public BacktraceDatabaseAttachmentManager(BacktraceDatabaseSettings settings)
        {
            _settings = settings;
            ScreenshotMaxHeight = Screen.height;
            ScreenshotQuality = 25;
        }

        public IEnumerable<string> GetReportAttachments(BacktraceData data)
        {
            var attachmentPrefix = data.UuidString;

            var result = new List<string>();
            try
            {
                AddIfPathIsNotEmpty(result, GetScreenshotPath(attachmentPrefix));
                AddIfPathIsNotEmpty(result, GetUnityPlayerLogFile(data, attachmentPrefix));
                AddIfPathIsNotEmpty(result, GetMinidumpPath(data, attachmentPrefix));
            }
            catch (Exception e)
            {
                Debug.LogWarning(string.Format("Cannot generate report attachments. Reason: {0}", e.Message));
            }
            return result;
        }

        private void AddIfPathIsNotEmpty(List<string> source, IEnumerable<string> attachmentPaths)
        {
            if (attachmentPaths == null || attachmentPaths.Count() == 0)
            {
                return;
            }
            foreach (var attachmentPath in attachmentPaths)
            {
                if (!string.IsNullOrEmpty(attachmentPath))
                {
                    source.Add(attachmentPath);
                }
            }
        }


        private void AddIfPathIsNotEmpty(List<string> source, string attachmentPath)
        {
            if (!string.IsNullOrEmpty(attachmentPath))
            {
                source.Add(attachmentPath);
            }
        }

        private string GetMinidumpPath(BacktraceData backtraceData, string dataPrefix)
        {
            if (_settings.MinidumpType == MiniDumpType.None)
            {
                return string.Empty;
            }
            //note that every minidump file generated by app ends with .dmp extension
            //its important information if you want to clear minidump file
            string minidumpDestinationPath = Path.Combine(_settings.DatabasePath, string.Format("{0}-dump.dmp", dataPrefix));
            var backtraceReport = backtraceData.Report;
            if (backtraceReport == null)
            {
                return string.Empty;
            }
            MinidumpException minidumpExceptionType = backtraceReport.ExceptionTypeReport
                ? MinidumpException.Present
                : MinidumpException.None;

            bool minidumpSaved = MinidumpHelper.Write(
                filePath: minidumpDestinationPath,
                options: _settings.MinidumpType,
                exceptionType: minidumpExceptionType);

            return minidumpSaved
                ? minidumpDestinationPath
                : string.Empty;
        }

        /// <summary>
        /// Get path to game screenshot when exception occured
        /// </summary>
        /// <returns>Path to game screenshot</returns>
        private List<string> GetScreenshotPath(string dataPrefix)
        {
            if (!_settings.GenerateScreenshotOnException)
            {
                return null;
            }
            var result = new List<string>();
            lock (_lock)
            {
                //if (BacktraceDatabase.LastFrameTime == _lastScreenTime)
                //{
                //    foreach (var screenPath in _screens)
                //    {
                //        if (File.Exists(screenPath))
                //        {
                //            File.Copy(screenPath, );
                //        }
                //    }
                //    return result;
                //}
                //else
                //{
                var screenshots = new string[Camera.allCamerasCount];
                float ratio = (float)Screen.width / (float)Screen.height;
                var applyDefaultSettings = ScreenshotMaxHeight == Screen.height;
                int targetHeight = applyDefaultSettings ? Screen.height : Mathf.Min(Screen.height, ScreenshotMaxHeight);
                int targetWidth = applyDefaultSettings ? Screen.width : Mathf.RoundToInt(targetHeight * ratio);

                var source = new Rect(0, 0, targetWidth, targetHeight);
                Camera[] Cameras = Camera.allCameras;
                RenderTexture previousActiveRT = RenderTexture.active;
                foreach (Camera camera in Cameras)
                {
                    var rt = RenderTexture.GetTemporary(targetWidth, targetHeight, 24);
                    //RenderTexture rt = new RenderTexture();
                    Texture2D screenShot = new Texture2D(targetWidth, targetHeight, TextureFormat.RGB24, false);

                    camera.targetTexture = rt;
                    camera.Render();
                    RenderTexture.active = rt;
                    screenShot.ReadPixels(source, 0, 0);
                    camera.targetTexture = null;
                    RenderTexture.active = null;

                    //GameObject.Destroy(rt);
#if UNITY_2019_1_OR_NEWER
                    RenderTexture.ReleaseTemporary(rt);
#else
                    GameObject.Destroy(rt);
#endif
                    //rt.Release();
                    var screenshotPath = Path.Combine(_settings.DatabasePath, string.Format("{0}-{1}.jpg", camera.name, dataPrefix));
                    File.WriteAllBytes(screenshotPath, screenShot.EncodeToJPG());

                    result.Add(screenshotPath);
                }
                RenderTexture.active = previousActiveRT;
                _lastScreenTime = BacktraceDatabase.LastFrameTime;
                _screens = result;
            }
            //}
            return result;
        }



        /// <summary>
        /// Get path to Unity player logs.
        /// </summary>
        /// <returns>Path to unity player log</returns>
        private string GetUnityPlayerLogFile(BacktraceData backtraceData, string dataPrefix)
        {
            if (!_settings.AddUnityLogToReport)
            {
                return string.Empty;
            }
            var playerLogPath =
#if UNITY_STANDALONE_LINUX
                    string.Format("~/.config/unity3d/{0}/{1}/Player.log", Application.companyName, Application.productName);
#elif UNITY_STANDALONE_OSX
                    string.Format("~/Library/Logs/{0}/{1}/Player.log", Application.companyName, Application.productName);
#elif UNITY_STANDALONE_WIN
                    Path.Combine(
                        Directory.GetParent(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData)).FullName,
                        string.Format("LocalLow/{0}/{1}/Player.log", Application.companyName, Application.productName));
#else
            string.Empty;
#endif
            if (string.IsNullOrEmpty(playerLogPath) || !File.Exists(playerLogPath))
            {
                return string.Empty;
            }
            var databaseLogPath = Path.Combine(_settings.DatabasePath, string.Format("{0}-lg.log", dataPrefix));
            File.Copy(playerLogPath, databaseLogPath);
            return databaseLogPath;
        }
    }
}
